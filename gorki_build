def Main():

    import xlsxwriter
    import pandas as pd
    import math
    import numpy as np
    import datetime
    from datetime import timezone
    
    #   получить имя пользователя для создания нужных папок
    import getpass
    sys_user = getpass.getuser()
    
    from pathlib import Path
    Path("C:/Users/" + sys_user + "/python_SAP_scripting/gorki_report").mkdir(parents=True, exist_ok=True)
    
    # загружаем исходные данные по фактическому потреблению
    #path = r"C:\Users\Maksim.Smirnov\python_SAP_scripting\MB51_current_report" + "\\ ".strip()
    path = r"C:\Users" + "\\ ".strip() + sys_user + "\\ ".strip() + "python_SAP_scripting\MB51_current_report" + "\\ ".strip()
    
    #path = path.replace('Maxim.Smirnov', sys_user)
    
    df_consumption = pd.read_excel(path + 'export_MB51.xlsx', dtype={'Material': 'str'})
    
    # вводим колонку с номером недели
    df_consumption['Week_Number'] = df_consumption['Entry Date'].dt.week
    # df_consumption['Entry Date'].dt.to_period('W').apply(lambda r: r.start_time).dt.week
    
    # считаем сумму по потреблению материала за конкретную неделю
    consumption_total = df_consumption.groupby(['Material', 'Week_Number'])["Quantity"].apply(lambda x : x.sum())
    consumption_total = consumption_total.to_frame().reset_index()
    
    # определеяем период планирования (мин номер недели и максимальный)
    #len(df_consumption['Week_Number'].value_counts())
    
    ##############################################################################################
    # удаляем строку, где нет даты. При имеющейся форме отчета из SAP- это последняя строка отчета ("итого")
    df_consumption = df_consumption[df_consumption['Entry Date'].notna()]
    
    df_consumption ['Y_W_D'] = df_consumption['Entry Date'].apply(lambda x: str(x.isocalendar()[0:2]))
    
    # фмируем timestamp недели, на которую выпала дата. Именно недели, а не конркетной даты, иначе группировка будет не по неделям, а по датам. 
    # Для этого в коде определяем неделю для каждой даты, но timestamp ей присваиваем для понедельника этой недели. В коде ниже за это отвечает '1' в strprtime
    df_consumption['datetime'] =  df_consumption['Y_W_D'].apply(lambda x: datetime.datetime.strptime( x[:-1]+', 1', '(%G, %V, %u').replace(tzinfo=timezone.utc).timestamp())
    
    # сортируем в порядке убывания datetime (на случай, если в выгрузке из SAP изменена хронология)
    df_consumption = df_consumption.sort_values(by=['datetime'], ascending=False)
    
    def week_year(x):
        return pd.to_datetime(x, unit='s', origin='unix').weekofyear

    # получаем хронологически в порядке убывания номера недель, с учетом года, на который номер недели выпадает
    df_consumption['week_from_time_stamp'] = df_consumption['datetime'].apply(lambda x : week_year(x))
    
    week_num_list = df_consumption['week_from_time_stamp'].drop_duplicates().to_list()
    week_num_list.reverse()
    


    
    min_week_num = week_num_list[0]
    max_week_num = week_num_list[len(week_num_list)-1]
    
    
    
    
    
    
    
    # min_week_num = int(df_consumption['Week_Number'].min())
    # max_week_num = int(df_consumption['Week_Number'].max())
    gorka_size = len(week_num_list) # max_week_num -min_week_num+1
    
    # составляем матрицу "заготовку" для заполнения данными размером min_wek_num x max_week_num
    df_gorka = pd.DataFrame(index=range(gorka_size),columns=range(gorka_size))
    
    # меняем названия колонок и рядов на номера недель и приводим к строковым переменным
    df_gorka.columns = list(map(str, week_num_list)) #[str(i) for i in range(min_week_num,max_week_num+1)]
    df_gorka.index = list(map(str, week_num_list)) # [str(i) for i in range(min_week_num,max_week_num+1)]
    
    
    
    # инициализирем файл, в который будут выгружаться данные
    writer = pd.ExcelWriter('C:/Users/' +sys_user +'/python_SAP_scripting/gorki_report/gorka_total.xlsx', engine='xlsxwriter')
    workbook  = writer.book
    
    # инициализируем общую таблицу, в которой будут содержаться все данные по каждой позиции
    df_gorka_total = df_gorka.iloc[:0,:]
    
    df_gorka_total.to_excel(writer, sheet_name='Sheet1', index=False, float_format = "%0.1f")
    worksheet = writer.sheets['Sheet1']
    
    # составляем список уникальных id материалов, полученных из транзакции MB51
    material_list = consumption_total ['Material'].unique().tolist()
    
    
    
    for material_id in material_list:
        
    
    
    # заполняем данными по фактическому потреблению
        for i in range(df_gorka.shape[0]):
            for j in range (i+1):
            
    
            
                if int(df_gorka.columns.values[i]) not  in list(consumption_total.loc[(consumption_total['Material'] == material_id)].iloc[:,1].astype(int)) :
                
                    df_gorka.iloc[i,j] = 0  
                else:
                    df_gorka.iloc[i,j] = int(math.ceil(abs(consumption_total.loc[(consumption_total['Week_Number'] == int(df_gorka.columns.values[i])) & 
                                  (consumption_total['Material'] == material_id)].iloc[0,2])))
               
            
                df_gorka['material_id']=material_id
            
              
       
                
    #  копируем данные из "верхней" ячейки на всю колонку                                   
        for m in range(df_gorka.shape[0]):
            for n in range (m+1,df_gorka.shape[0]):
                df_gorka.iloc[n,m] = df_gorka.iloc[n-1,m]  
    
        
        
    #    os.system( 'python C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/gorki_forecast_loop.py')
     #   runpy.run_path('C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/gorki_forecast_loop.py')
        
        
        
        
    ##############################################    
        
    
        
        
        
        
        # df_gorka_total = pd.concat([df_gorka_total, df_gorka] , sort=False)
        # cols = df_gorka_total.columns
        
        # df_gorka_total = df_gorka_total[cols]
        # df_gorka_total.append(df_gorka, sort=False)
        df_gorka_total = df_gorka_total.append(df_gorka)[df_gorka.columns.tolist()]
        
        
    # обогащаем результирущую таблицу названиями позиций
    df_gorka_total = pd.merge(df_gorka_total, 
    df_consumption.drop_duplicates(subset=['Material'])[['Material','Material Description']], 
                                    how='left', left_on='material_id', right_on='Material')
            
          
    df_gorka_total = df_gorka_total.drop('Material', 1)
    
    #вводим колонку с номерами недель, попавшими в отчет, делаем это для каждой позиции   
    # repeat_arr = list(range(min_week_num , max_week_num+1))
    repeat_arr = week_num_list
    df_gorka_total = df_gorka_total.join(pd.DataFrame(repeat_arr * int((len(df_gorka_total)/len(repeat_arr)+1)),columns=['week_num']))
    
    
    #меняем колонки местами
    cols_to_order = ['material_id', 'Material Description', 'week_num']
    new_columns = cols_to_order + (df_gorka_total.columns.drop(cols_to_order).tolist())
    df_gorka_total = df_gorka_total[new_columns]    
    
    ###################################################################################################################
    
    import os
    import pandas as pd
    
    # material_id = '21072242'
    
    list_of_forecasts = os.listdir('C:/Users/' + sys_user +'/python_SAP_scripting/cooispi_forecast_history/')
    
    # инициализируем результирующую табилцу
    df_gorka_total_forecast = df_gorka_total
    
    for forecast in list_of_forecasts:
                
        
        
        df_forecast_new_template  = pd.read_excel('C:/Users/' + sys_user +'/python_SAP_scripting/cooispi_forecast_history/' + forecast, dtype={'Material': 'str'})
        df_forecast_new_template['Requirement quantity (EINHEIT)'] =df_forecast_new_template['Requirement quantity (EINHEIT)'].astype(float)
        # округление до 3 знака 
        df_forecast_new_template['Requirement quantity (EINHEIT)'] = df_forecast_new_template['Requirement quantity (EINHEIT)'].apply(lambda x:round(x,3))
        
        # добавляем колонку с номером недели
        df_forecast_new_template['Week_Number'] = df_forecast_new_template['Requirement date'].dt.week
        
        # строим сводную таблицу номер недели/ кол-во потребленного
        df_forecast = df_forecast_new_template.pivot_table(
                values='Requirement quantity (EINHEIT)', 
                index=['Material', 'Material Description'], 
                columns='Week_Number', 
                aggfunc=sum).rename_axis(None, axis=1).reset_index()
        
        df_forecast.columns = df_forecast.columns.map(str)
        # проверяем имеются ли недели в прогнозе, которые совпадают с неделями из фактического потребления 
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        # import datetime
        # from datetime import timezone
        
        df_forecast_new_template['Y_W_D'] = df_forecast_new_template['Requirement date'].apply(lambda x: str(x.isocalendar()[0:2]))
           
        
        df_forecast_new_template['datetime'] =  df_forecast_new_template['Y_W_D'].apply(lambda x: datetime.datetime.strptime( x[:-1]+', 1', '(%G, %V, %u').replace(tzinfo=timezone.utc).timestamp())
        
        df_forecast = df_forecast_new_template.pivot_table(
                        values='Requirement quantity (EINHEIT)', 
                        index=['Material', 'Material Description'], 
                        columns='datetime', 
                        aggfunc=sum).rename_axis(None, axis=1).reset_index()
         
        
        
        def week_year(x):
            return pd.to_datetime(x, unit='s', origin='unix').weekofyear
        
        
        
        df_forecast.columns = df_forecast.columns [:2].tolist() + list(map(week_year, df_forecast.columns[2:df_forecast.shape[1]]))
        
        df_forecast.columns = df_forecast.columns.map(str)
        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        if len(list(set(list(df_gorka_total_forecast)[3:]) & set(list(df_forecast)[2:]))) < 2 or  len(list(set(list( df_gorka_total_forecast['week_num'])) & set([float(df_forecast.columns[2])])))==0:
            continue
        
       
        
    
       
       
        
        
        
        
        
        # ищем индексы вхождения номера первой указанной недели, в названиях колонок
        # номера недель после годового цикла повторяются, а для очтета "горка" нужны только уникальные "ближайшие" недели
        # неободимо отбросить те, которые повторятся после годового цикла
        repeated_week_cycle = [i for i, e in enumerate(df_forecast.columns) if e == df_forecast.columns[2]] # df_forecast.columns[2] - номер "первой" недели прогноза
        
        # "обрезаем" таблицу, если годовой цикл начался снова
        if len (repeated_week_cycle) > 1:
            df_forecast = df_forecast.iloc[:, :repeated_week_cycle[1]]
        else:
            df_forecast = df_forecast   
        # df_forecast.columns.values
        
        # для каждой позиции в уже подготовленной "горке" df_gorka_total из обработанного файла с прогнозами по всем позициям df_forecast 
        # вставляем все данные по прогнозу на неделю, которая указана первой в df_forecast 
    
    
            
        for  material_id in material_list:
            
            #тест
            #material_id = '21072242'
            
            # обработка ошибок
            # # делаем выборку для конкретного материала из общего файла с прогнозом
            # if df_forecast.loc[df_forecast['Material']==df_gorka.iloc[0]['material_id']].shape[0] == 0:
            #     continue
               
                
            df_id_material_forecast =   df_forecast.loc[df_forecast['Material']==material_id] 
            
                
               ######
            #обработка ошибок
            
            # if list_of_forecasts.index(forecast)>0:
            #     df_gorka_forecast = pd.concat([df_gorka_forecast, df_id_material_forecast.iloc[:,0:len(df_id_material_forecast.columns)]])
            # else:
            #     df_gorka_forecast = pd.concat([df_gorka, df_id_material_forecast.iloc[:,0:len(df_id_material_forecast.columns)]])
            
            
            # делаем выборку для конкретного материала из общего файла с прогнозом, если прогноза нет, то переходим к следующему материалу в "горке"
            if df_id_material_forecast.shape[0] == 0:
                continue
            
            # записываем строку с прогнозом по позиции "под" общим отчетом
            df_gorka_total_forecast = pd.concat([df_gorka_total_forecast, df_id_material_forecast.iloc[:,0:len(df_id_material_forecast.columns)]])  
                
            
            
            # индекс строки, в которой в общем файле находится нужный материал и неделя, для которой найден прогноз
            # df_gorka_total_forecast[(df_gorka_total_forecast['material_id']  == material_id) & (df_gorka_total_forecast['week_num'] ==  float(df_forecast.columns[2]))].index.tolist()
            
            
            # df_id_material_forecast =   df_forecast.loc[df_forecast['Material']==df_gorka.iloc[0]['material_id']] 
            
            
            # df_gorka_total_forecast = pd.concat([df_gorka_total, df_id_material_forecast.iloc[:,0:len(df_id_material_forecast.columns)]])
            
            
            # "обрезаем" лишнне после соеденения таблиц
            #df_gorka_forecast = df_gorka_forecast.iloc[0:df_gorka.shape[0]+1, 0:df_gorka.shape[1]]
            
            
            # индекс строки, которая соответствует недели, на которой был составлен прогноз и которую нужно найти в горке по горизонтали
            forecast_week_number_index = df_gorka_total_forecast[(df_gorka_total_forecast['material_id']  == material_id) & (df_gorka_total_forecast['week_num'] ==  float(df_forecast.columns[2]))].index[0]
            
            
            #вставляем данные по прогнозу в строку с найденным индексом
            df_gorka_total_forecast.iloc[forecast_week_number_index, (forecast_week_number_index % len(repeat_arr)+4):] = df_gorka_total_forecast.iloc[df_gorka_total_forecast.shape[0]-1, (forecast_week_number_index % len(repeat_arr)+4):]
            
            
            # удаляем 1 ряд снизу и лишние данные "справа"
            df_gorka_total_forecast = df_gorka_total_forecast.iloc[:df_gorka_total_forecast.shape[0]-1, :]
            #df_gorka_total_forecast.drop(df_gorka_total_forecast.tail(1).index,inplace=True)
            df_gorka_total_forecast = df_gorka_total_forecast.iloc[:, :- (df_gorka_total_forecast.shape[1]-df_gorka_total.shape[1])]
    
    
    
    
    
    
    
        
    df_gorka_total = df_gorka_total_forecast
    
    #df_gorka_total.loc[:,'Итого'] = df_gorka_total.sum(axis=1)
    
    from contextlib import suppress

    with suppress(Exception):
    
        col_list = list(df_gorka_total.columns[3:df_gorka_total.shape[1]])
        df_gorka_total['Итого'] = df_gorka_total[col_list].sum(axis=1)
        df_gorka_total['Среднее значение'] = df_gorka_total[col_list].mean(axis=1)
        df_gorka_total['% изменений']=df_gorka_total.loc[:,'Итого'].pct_change(periods=1, axis=0).dropna(0)
        df_gorka_total['% изменений'] = df_gorka_total['% изменений'].astype(float).map("{:.2%}".format)
        
        for i in range(df_gorka_total.shape[0]-1):
            col_list = list(df_gorka_total.columns[ ( (df_gorka_total.loc[i]['week_num']).astype(int)-(df_gorka_total['week_num'][0]).astype(int) +4) :df_gorka_total.shape[1]-5  ])
            #print(col_list)
            mean_of_row= df_gorka_total.iloc[i][col_list].mean()
            df_gorka_total.at[i,'Среднее за весь прогнозный период'] =mean_of_row
        
        
        # for i in range(df_gorka_total.shape[0]-1):
            col_list = list(df_gorka_total.columns[3: ( (df_gorka_total.loc[i]['week_num']).astype(int)-(df_gorka_total['week_num'][0]).astype(int) +4)   ])
            #print(col_list)
            sum_of_row= df_gorka_total.iloc[i][col_list].mean()
            df_gorka_total.at[i,'Среднее за весь фактический период'] =sum_of_row
        
        df_gorka_total['Отношение среднего плана к факту'] = df_gorka_total['Среднее за весь прогнозный период']/ df_gorka_total['Среднее за весь фактический период']

########################################################################################################################

        # загружаем исходные данные по MB52
    #путь к папке с фактическими остатками
   
    path = r"C:\Users" + "\\ ".strip() + sys_user + "\\ ".strip() + "python_SAP_scripting\MB52_current_report" + "\\ ".strip()
        
 
    
    #Обработка ошибок, в случае, если папки  с отчетами MB52 нет или папка пустая
    try:
        list_of_MB52_reports = os.listdir('C:/Users/' + sys_user +'/python_SAP_scripting/MB52_stock_history/')
    except OSError:
                pass 
    
    # в случае, если папка не пустая, то будут обработаны только те файлы, которые относятся к периоду "горки"
    if len(list_of_MB52_reports) !=0:
        
    
        import re
        
        # функция для определения номера недели из имени файла по маске "MB52_{номер недели}_{день недели}", например, "MB52_w22_Monday"
        def report_week_number(x):
            return x[6:([m.start() for m in re.finditer('_', x)][1])]
        
        # получаем список недель, к которым относятся выгруженные очтеты в папке       
        week_num_report_list = list(map(report_week_number, list_of_MB52_reports)) 
        week_num_report_list = list(map(int,week_num_report_list))
        
        # определеяем какие отчеты нужны для включения в горку по номеру недели (если номер недели пристутвует в отчете для "горки", то отчет включаем)
        both= set(week_num_list).intersection(week_num_report_list)
        required_reports_indices = [week_num_report_list.index(x) for x in both]
        
        required_reports_list = list(pd.Series(list_of_MB52_reports)[ required_reports_indices])
        
        
        #df_stock  = pd.read_excel('C:/Users/' + sys_user +'/python_SAP_scripting/MB52_stock_history/' + stock_report, dtype={'Material': 'str'})
        df_stock_all_reports = pd.DataFrame()
        
        for stock_report in required_reports_list:
            
            df_stock  = pd.read_excel('C:/Users/' + sys_user +'/python_SAP_scripting/MB52_stock_history/' + stock_report, dtype={'Material': 'str'})
            # вставить номер недели,на которой был выгружен очтет
            df_stock ['week_num']= int(report_week_number (stock_report))
            
            df_stock_all_reports =df_stock_all_reports.append(df_stock)
            
        
            
        df_stock_total = df_stock_all_reports.groupby(['Material', 'week_num'])["Unrestricted"].apply(lambda x : x.sum()).reset_index()
    else:
        pass
    # при необходимости создается отедльная таблица df_gorka_MB52
    # df_gorka_MB52 = pd.merge(df_gorka_total, df_stock_total, how='left', left_on=['material_id', 'week_num'], right_on=['Material', 'week_num'] )
    
    
    # cols_to_order = ['material_id', 'Material Description', 'week_num', 'Unrestricted']
    # new_columns = cols_to_order + (df_gorka_MB52.columns.drop(cols_to_order).tolist())
    # df_gorka_MB52 = df_gorka_MB52[new_columns]    
    # df_gorka_MB52.rename(columns={'Unrestricted': 'Unrestricted_stock'}, inplace=True)
    
    df_gorka_total = pd.merge(df_gorka_total, df_stock_total, how='left', left_on=['material_id', 'week_num'], right_on=['Material', 'week_num'] )
    
    
    cols_to_order = ['material_id', 'Material Description', 'week_num', 'Unrestricted']
    new_columns = cols_to_order + (df_gorka_total.columns.drop(cols_to_order).tolist())
    df_gorka_total = df_gorka_total[new_columns]    
    df_gorka_total.rename(columns={'Unrestricted': 'Unrestricted_stock'}, inplace=True)
    df_gorka_total.drop(['Material'], axis=1, inplace=True)




















    ######################################################################################
    
    
        # загружаем исходные данные по me5a
    #путь к папке с фактическими остатками
   
    
    #Обработка ошибок, в случае, если папки  с отчетами me5a нет или папка пустая
    try:
        list_of_me5a_reports = os.listdir('C:/Users/' + sys_user +'/python_SAP_scripting/me5a_history/')
    except OSError:
                pass 
    
    # в случае, если папка не пустая, то будут обработаны только те файлы, которые относятся к периоду "горки"
    if len(list_of_me5a_reports) !=0:
        
    
        # import re
        
        # # функция для определения номера недели из имени файла по маске "MB52_{номер недели}_{день недели}", например, "MB52_w22_Monday"
        # def report_week_number(x):
        #     return x[6:([m.start() for m in re.finditer('_', x)][1])]
        
        # получаем список недель, к которым относятся выгруженные очтеты в папке       
        week_num_report_list = list(map(report_week_number, list_of_me5a_reports)) 
        week_num_report_list = list(map(int,week_num_report_list))
        
        # определеяем какие отчеты нужны для включения в горку по номеру недели (если номер недели пристутвует в отчете для "горки", то отчет включаем)
        both= set(week_num_list).intersection(week_num_report_list)
        required_reports_indices = [week_num_report_list.index(x) for x in both]
        
        required_reports_list = list(pd.Series(list_of_me5a_reports)[ required_reports_indices])
        
        
        #df_stock  = pd.read_excel('C:/Users/' + sys_user +'/python_SAP_scripting/MB52_stock_history/' + stock_report, dtype={'Material': 'str'})
        df_stock_all_reports = pd.DataFrame()
        
        for stock_report in required_reports_list:
            
            df_stock  = pd.read_excel('C:/Users/' + sys_user +'/python_SAP_scripting/me5a_history/' + stock_report, dtype={'Material': 'str'})
            
            # оставляем только данные с заданным признаком
            df_stock  = df_stock.loc[df_stock ['"Fixed" Indicator'] == 'Yes']
            # вставить номер недели,на которой был выгружен очтет
            df_stock ['week_num']= int(report_week_number (stock_report))
            
            df_stock_all_reports =df_stock_all_reports.append(df_stock)
            
        
            
        df_stock_total = df_stock_all_reports.groupby(['Material', 'week_num'])["Quantity Requested"].apply(lambda x : x.sum()).reset_index()
    else:
        pass
    # при необходимости создается отедльная таблица df_gorka_MB52
    # df_gorka_MB52 = pd.merge(df_gorka_total, df_stock_total, how='left', left_on=['material_id', 'week_num'], right_on=['Material', 'week_num'] )
    
    
    # cols_to_order = ['material_id', 'Material Description', 'week_num', 'Unrestricted']
    # new_columns = cols_to_order + (df_gorka_MB52.columns.drop(cols_to_order).tolist())
    # df_gorka_MB52 = df_gorka_MB52[new_columns]    
    # df_gorka_MB52.rename(columns={'Unrestricted': 'Unrestricted_stock'}, inplace=True)
    
    df_gorka_total = pd.merge(df_gorka_total, df_stock_total, how='left', left_on=['material_id', 'week_num'], right_on=['Material', 'week_num'] )
    
    
    
################################################
        # загружаем исходные данные по me2m
    
    
 
    
    #Обработка ошибок, в случае, если папки  с отчетами me2m нет или папка пустая
    try:
        list_of_me2m_reports = os.listdir('C:/Users/' + sys_user +'/python_SAP_scripting/me2m_history/')
    except OSError:
                pass 
    
    # в случае, если папка не пустая, то будут обработаны только те файлы, которые относятся к периоду "горки"
    if len(list_of_me2m_reports) !=0:
        
    
        # import re
        
        # # функция для определения номера недели из имени файла по маске "MB52_{номер недели}_{день недели}", например, "MB52_w22_Monday"
        # def report_week_number(x):
        #     return x[6:([m.start() for m in re.finditer('_', x)][1])]
        
        # получаем список недель, к которым относятся выгруженные очтеты в папке       
        week_num_report_list = list(map(report_week_number, list_of_me2m_reports)) 
        week_num_report_list = list(map(int,week_num_report_list))
        
        # определеяем какие отчеты нужны для включения в горку по номеру недели (если номер недели пристутвует в отчете для "горки", то отчет включаем)
        both= set(week_num_list).intersection(week_num_report_list)
        required_reports_indices = [week_num_report_list.index(x) for x in both]
        
        required_reports_list = list(pd.Series(list_of_me2m_reports)[ required_reports_indices])
        
        
        #df_stock  = pd.read_excel('C:/Users/' + sys_user +'/python_SAP_scripting/MB52_stock_history/' + stock_report, dtype={'Material': 'str'})
        df_stock_all_reports = pd.DataFrame()
        
        for stock_report in required_reports_list:
            
            df_stock  = pd.read_excel('C:/Users/' + sys_user +'/python_SAP_scripting/me2m_history/' + stock_report, dtype={'Material': 'str'})
            # вставить номер недели,на которой был выгружен очтет
            df_stock ['week_num']= int(report_week_number (stock_report))
            
            df_stock_all_reports =df_stock_all_reports.append(df_stock)
            
            
        df_stock_total = df_stock_all_reports.groupby(['Material', 'week_num'])["Still to be delivered (qty)"].apply(lambda x : x.sum()).reset_index()
    else:
        pass
    

    
    
    # при необходимости создается отедльная таблица df_gorka_MB52
    # df_gorka_MB52 = pd.merge(df_gorka_total, df_stock_total, how='left', left_on=['material_id', 'week_num'], right_on=['Material', 'week_num'] )
    
    
    # cols_to_order = ['material_id', 'Material Description', 'week_num', 'Unrestricted']
    # new_columns = cols_to_order + (df_gorka_MB52.columns.drop(cols_to_order).tolist())
    # df_gorka_MB52 = df_gorka_MB52[new_columns]    
    # df_gorka_MB52.rename(columns={'Unrestricted': 'Unrestricted_stock'}, inplace=True)
    
    df_gorka_total = pd.merge(df_gorka_total, df_stock_total, how='left', left_on=['material_id', 'week_num'], right_on=['Material', 'week_num'] )
       
    cols = ['Quantity Requested', 'Still to be delivered (qty)' ]
    df_gorka_total[cols] = df_gorka_total[cols].fillna(0)
    
    df_gorka_total['me5a+me2m'] = df_gorka_total['Quantity Requested'] + df_gorka_total['Still to be delivered (qty)']
 
    
    
    
    
    cols_to_order = ['material_id', 'Material Description',  'Unrestricted_stock', 'me5a+me2m', 'week_num']
    new_columns = cols_to_order + (df_gorka_total.columns.drop(cols_to_order).tolist())
    df_gorka_total = df_gorka_total[new_columns]    
    # df_gorka_total.rename(columns={'Unrestricted': 'Unrestricted_stock'}, inplace=True)
    df_gorka_total = df_gorka_total.iloc [:,:-4]
    # df_gorka_total.drop(['Material'], axis=1, inplace=True)
    df_gorka_total['Unrestricted_stock'].fillna(0, inplace = True)
    
    
    
   
    
    
    
    
    
    # создаем таблицу копируя в нее только численные данные
    df_gorka_total_netto_digits = df_gorka_total.iloc[:, 5: 5+gorka_size]
    df_gorka_total_netto_digits.columns = range(df_gorka_total_netto_digits.shape[1])
    df_gorka_total_netto_digits.fillna(0, inplace = True)
    
    
    # индексы колонок в зависимости от ряда
   # df_gorka_total_netto_digits['column_range']= df_gorka_total_netto_digits.apply(lambda row:  row.index[row.name+1:] if row.index[row.name] == row.name  else None, axis=1)
    df_gorka_total_netto_digits['column_range']= df_gorka_total_netto_digits.apply(lambda row:  row.index[row.name+1:] 
                                                                                   if row.index[0 if row.name % gorka_size == 0 
                                                                                                else row.name % gorka_size] == row.name  else None, axis=1)
    # т.к. "горки" для всех позиций имеют одиниковую структуру, то копируем получившийся список индексов  
    df_gorka_total_netto_digits['column_range'] = list(df_gorka_total_netto_digits['column_range'].loc[:gorka_size-1]) * int((df_gorka_total_netto_digits.shape[0]/gorka_size))
 
    
    def row_diff(x):
       test_list = x [x['column_range']]
       res = list(x[x['column_range']])
       # res = list([test_list[i + 1] - test_list[i] for i in range(len(test_list)-1)]) 
       return res
   

        
    df_gorka_total_netto_digits['forecast'] = df_gorka_total_netto_digits.apply(row_diff, axis=1) #.loc[:6]
   
   # изменить на i- i+1
    def diff (x):
       res = list([x['forecast'][i ] - x['forecast'][i+1] for i in range(len(x['forecast'])-1)]) 
       return res


    df_gorka_total_netto_digits['diff'] = df_gorka_total_netto_digits.apply(diff, axis=1) 
   # df_gorka_total_netto_digits.drop(['column_range'], axis=1, inplace=True)
   
   
   
   
   
   # список колонок с фактическими продажами
   # пришлось создать отдельную таблицу с дальншей конкатенацией. Внутри одной таблицы не работали range с индексами для прогнозов и фактов
   
    df_gorka_total_netto_digits2 = df_gorka_total.iloc[:, 5: 5+gorka_size]
    df_gorka_total_netto_digits2.columns = range(df_gorka_total_netto_digits2.shape[1])
    df_gorka_total_netto_digits2.fillna(0, inplace = True)
    
    df_gorka_total_netto_digits2['column_fact_range']= df_gorka_total_netto_digits2.apply(lambda row:  row.index[:row.name+1] 
                                                                                          if row.index[0 if row.name % gorka_size == 0 
                                                                                                       else row.name % gorka_size] == row.name  else None, axis=1)
    df_gorka_total_netto_digits2['column_fact_range'] = list(df_gorka_total_netto_digits2['column_fact_range'].loc[:gorka_size-1]) * int((df_gorka_total_netto_digits2.shape[0]/gorka_size))
    
    def row_diff(x):
       test_list = x [x['column_fact_range']]
       res = list(x[x['column_fact_range']])
       # res = list([test_list[i + 1] - test_list[i] for i in range(len(test_list)-1)]) 
       return res
   
    
    df_gorka_total_netto_digits2['fact'] = df_gorka_total_netto_digits2.apply(row_diff, axis=1)
    df_out = df_gorka_total_netto_digits2.apply(row_diff, axis=1)
    
    
    df_gorka_total_netto_digits = pd.concat([df_gorka_total_netto_digits, df_gorka_total_netto_digits2['fact']], axis =1)
    
    # выделим первый эелемент в списке значений прогноза
    df_gorka_total_netto_digits ['first_stock']= df_gorka_total_netto_digits['forecast'].apply(lambda x: x[0] if len(x) !=0 else None)
    
    # расчитаем остаток на первой прогнозной неделе
    df_gorka_total_netto_digits ['first_stock_forecast'] = df_gorka_total ['Unrestricted_stock']+df_gorka_total ['me5a+me2m']-df_gorka_total_netto_digits ['first_stock']
   
    # обнуляем результат потребности для перовго эелемента, если он больше нуля. Положительный результат показывает, что потребность ниже,
    # чем остаток, поэтому заказывать что-либо не нужно
    
    # def make_zero_element (x):
    #     if x > 0:
    #         t =0
    #     else: 
    #         t =x
    #         return t
    
    
    
    # df_gorka_total_netto_digits ['first_stock_forecast'] = df_gorka_total_netto_digits ['first_stock_forecast'].apply(lambda x: 0 if x >0 else x)
    
    
    
    # функция для расчтета убывающего остатка накопительным итогом, начиная со второй прогнозной недели
    # результирующий остаток на первой прогнозной неделе = MB52 + me2m+ me5a- cooispi на 1-й неделе
    # результирующий остаток на последующих неделях поулчается вычитаением cooispi на соответствующей неделе рекусивно из полученного остатка 
    # остаток становится отрицательным, то нужно взять значение по модулю, а все последующие значения нетто потребности
    # станут равны данным по cooispi на соответствующей неделе
    
    # старый вариант
    # def cumulative_stock (consumption_list):
    #     try:
    #         final_stock_by_week = [consumption_list[0]]
    #         if consumption_list[0] <0:
    #             flag_negative =1
    #             final_stock_by_week[0] = abs(final_stock_by_week[0])
                
    #         else:
    #             flag_negative = 0
    #         for i in range (len(consumption_list)-1):
    #             if flag_negative !=1 and consumption_list[i+1] !=0:
    #                 final_stock_by_week.append (final_stock_by_week[i]- consumption_list[i+1])
    #                 # если "флаг" с отрицательным остатком "не включен", но потребление равно 0 на конкретной неделе, 
    #                 # то нетто потребностьтоже равна 0
    #             elif flag_negative !=1 and consumption_list[i+1]==0:
    #                 final_stock_by_week.append (consumption_list[i+1])
                
    #             else:
    #                   final_stock_by_week.append (consumption_list[i+1])  
    #             # если элемент имеет отрицательное значение, то берем его по модулю и делаем "флаг" с признаком отрицательных значений
    #             if final_stock_by_week[i+1]<0:
    #                final_stock_by_week[i+1] = abs (final_stock_by_week[i+1]) 
    #                flag_negative = 1
                   
    #         return final_stock_by_week
    #     except Exception:
    #         pass
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    # def cumulative_stock (consumption_list):
    #     try:
    #         final_stock_by_week = [consumption_list[0]]
    #         if consumption_list[0] <0:
    #             flag_negative =1
    #             final_stock_by_week[0] = abs(final_stock_by_week[0])
                
    #         else:
    #             flag_negative = 0
    #         for i in range (len(consumption_list)-1):
    #             if flag_negative !=1 and consumption_list[i+1] !=0:
    #                 final_stock_by_week.append (final_stock_by_week[i]- consumption_list[i+1])
    #                 # если "флаг" с отрицательным остатком "не включен", но потребление равно 0 на конкретной неделе, 
    #                 # то нетто потребностьтоже равна 0
    #             elif consumption_list[i+1]==0:
    #                 final_stock_by_week.append (consumption_list[i+1])
                
    #             else:
    #                   final_stock_by_week.append (consumption_list[i+1])  
    #             # если элемент имеет отрицательное значение, то берем его по модулю и делаем "флаг" с признаком отрицательных значений
    #             if final_stock_by_week[i+1]<0:
    #                final_stock_by_week[i+1] = abs (final_stock_by_week[i+1]) 
    #                flag_negative = 1
                   
    #         return final_stock_by_week
    #     except Exception:
    #         pass  
    
    # функция для замены первого элемента с брутто прогнозом на расчетный прогнозный остаток
    def replace_first_element(x):
        try:
            x['forecast'][0]= x ['first_stock_forecast']
            
            return x['forecast'] 
        except Exception:
            pass
    
    
    def cumulative_stock (consumption_list):
        try:
            # инициализируем 2 массива
            # в массив будут собираться элементы, рекусивным вычитанием из остатка потребности
            final_stock_by_week = [consumption_list[0]]
            # в массив будут собираться элементы в зависимости от знака остатка в final_stock_by_week
            net_order_volume  = [final_stock_by_week[0]]
            if consumption_list[0] <=0:
                # flag_negative =1
                # final_stock_by_week[0] = abs(final_stock_by_week[0])
                net_order_volume  = [abs(final_stock_by_week[0])]
                
            else:
                # final_stock_by_week[0] =0
                net_order_volume[0]  =0
                
            for i in range (len(consumption_list)-1): #len(consumption_list)-1
              
                # if flag_negative !=1 :
                final_stock_by_week.append (final_stock_by_week[i]- consumption_list[i+1])
                    
                    
                    
                    
                if final_stock_by_week[i+1] >= 0:
                    flag_negative =0
                    net_order_volume.append (0)
                else:
                    # final_stock_by_week[i] = final_stock_by_week[i]
                    flag_negative =1
                    net_order_volume.append (abs(final_stock_by_week[i+1]) if final_stock_by_week[i]>0 else  consumption_list[i+1]) #if flag_negative==0 else  consumption_list[i+1])
                    # net_order_volume.append (consumption_list[i+1])
                    
                          
                          
                           
                    # если "флаг" с отрицательным остатком "не включен", но потребление равно 0 на конкретной неделе, 
                    # то нетто потребностьтоже равна 0
                # elif consumption_list[i+1]==0:
                #     final_stock_by_week.append (consumption_list[i+1])
                
                # else:
                #       final_stock_by_week.append (consumption_list[i+1])  
                # если элемент имеет отрицательное значение, то берем его по модулю и делаем "флаг" с признаком отрицательных значений
                # if final_stock_by_week[i+1]<0:
                #    final_stock_by_week[i+1] = abs (final_stock_by_week[i+1]) 
                #    flag_negative = 1
                   
            return net_order_volume #final_stock_by_week[0] #net_order_volume
        except Exception:
            pass 
           
    df_gorka_total_netto_digits ['first_stock_week_range']  =  df_gorka_total_netto_digits.apply(replace_first_element, axis =1) 
    df_gorka_total_netto_digits ['cumulative_stock']= df_gorka_total_netto_digits['first_stock_week_range'].apply(cumulative_stock )
    
    # объединяем массивы, содержащие данные по факту и плану для последующего разбиения по колонкам для поулчания формата "гоорки"
    df_gorka_total_netto_digits ['gorka_pattern']= df_gorka_total_netto_digits ['fact'] + df_gorka_total_netto_digits ['cumulative_stock']
    
    # меняем эелементы с пустым значением (это значение в последней строке "горки", где содержатся только данные по фактическому потреблению)
    df_gorka_total_netto_digits['gorka_pattern'].loc[df_gorka_total_netto_digits['gorka_pattern'].isnull()] = df_gorka_total_netto_digits['fact']
    

    
    # разбиваем полученный список из занчений факта и остатка накопительным итогом на столбцы
    df_gorka_total_netto_digits [list(map(str,  week_num_list))]= pd.DataFrame(df_gorka_total_netto_digits.gorka_pattern.tolist(), index= df_gorka_total_netto_digits.index)
    
    # создаем таблицу "одна под другой"
    df_double_gorka = pd.concat([df_gorka_total, df_gorka_total_netto_digits.iloc[:, -gorka_size:]], axis =1)

    df_first_gorka = df_double_gorka.iloc[:, :gorka_size+11]
    
    rng = list(range(0,5)) + list(range( gorka_size+5+6, len(df_double_gorka.columns) )) + list(range(gorka_size+5, gorka_size+11))
                                  
    df_second_gorka = df_double_gorka.iloc[:, rng]
    
    # присваиваем "флаг" 1- горка брутто, 2- горка нетто
    df_first_gorka['flag'] = '1'
    df_second_gorka['flag'] = '2'
    
    df_gorka_brutto_netto = df_first_gorka.append([df_second_gorka])
    df_gorka_brutto_netto = df_gorka_brutto_netto.sort_values(['material_id', 'flag'], ascending=[True, True])
    
    # df_gorka_brutto_netto.drop(['flag'], axis=1, inplace=True)
    
    df_gorka_total = df_gorka_brutto_netto










    
        
    ####################################################################################################################
        # инициализирем файл, в который будут выгружаться данные
    # writer = pd.ExcelWriter('C:/Users/' +sys_user +'/python_SAP_scripting/gorki_report/gorka_total.xlsx', engine='xlsxwriter')
    # workbook  = writer.book
        
    df_gorka_total.to_excel(writer, sheet_name='Sheet1', index=False, float_format = "%0.1f")
    worksheet = writer.sheets['Sheet1']    
    
    # проходим циклом по ячейкам для форматирования "горки" с фактичесим потребелением "серым" цветом
    for i in range(df_gorka_total.shape[0]):
        
        if i % gorka_size == 0:
            t =0
        else:
            t= i % gorka_size
        
        for j in range (4,t+5): # при смещении "горки" на 1 колонку  увеличить начало и конец диапазона на 1
            # инициализиаруем ячейку, к которой будет применено форматирование, получаем значение формата "А1"
            range_df = chr(98+j).upper()+str(i+2) 
             
            # задаем формат, который будет применен для ячейки
            format1 = workbook.add_format({'bg_color': '#ACAAAA',
                                    'font_color': '#9C0006',
                                    'border':1
                                    })
            
            format2 = workbook.add_format({'bg_color': '#3CCA3E',
                                    'font_color': '#9C0006',
                                    'border':1
                                    })
            
            

            worksheet.conditional_format(range_df, {'type': 'no_errors',
                                                    'format': format1})
            
    
    #рассчитать среднее значение по прогнозам для каждой недели
    # выделить цветом отклонение от среднего на 30%        
    
  
    
    ##########################################
    # инициализируем список (list of lists), внутри которого будут собраны списки прогнозных заначений (версии плана) для каждого элемента, 
    # для каждого элемента будет рассчитано среднее значение      
    # avrg_forecast = [] 
      
    # for column in range (4, gorka_size+3):
    #     avrg_forecast.append (list(df_gorka_total.iloc[0:column-3, column])) 
        
    def fun_mean_list(x):
        return sum(x)/len(x)
    
    def fun_replace_nan (x):
        return pd.Series(x, dtype=object).fillna(0).tolist()
    
    # avrg_forecast = list(map(fun_replace_nan, avrg_forecast))

    ##########################################    
    
    
    
    myList = range(0, df_gorka_total.shape[0])
    
    for i in myList[0::gorka_size]:
        #print (i)
    
    
    
         
    #for i in range(df_gorka_total.shape[0]): #############################
        if i % gorka_size==0:
            avrg_forecast = [] 
      
            for column in range (5, gorka_size+5): # при смещении "горки" на 1 колонку  увеличить слагаемое на 1
                avrg_forecast.append (list(df_gorka_total.iloc[i:i+column-3, column])) 
                avrg_forecast = list(map(fun_replace_nan, avrg_forecast))
    
                # список средних за каждую неделю
                list_of_avrgs = list(map(fun_mean_list, avrg_forecast))
        

        # делаем условное форматирование только для горок с "брутто" результатом   
        if  df_gorka_total['flag'].iloc[i]=='1' :
            for j in range (5, gorka_size+4):# при смещении "горки" на 1 колонку  увеличить наачало range и слагаемое на 1
                
                for m in range (2, j-1): ########################## 0 заменен на 2 в range
               
                   
                    #avrg_forecast.append (list(df_gorka_total.iloc[0:m, j]))   
                    # инициализируем ячейку, к которой будет применено форматирование, получаем значение формата "А1"
                    range_df = chr(98+j).upper()+str(i+m)   
                       
                    
                    worksheet.conditional_format(range_df, {'type': 'cell',
                                                        'criteria': '>',
                                                        'value': list_of_avrgs[j-5] * 1.3, # при смещении "горки" на 1 колонку  увеличить вычитаемое на 1
                                                        'format': format2})       
    




    
    # df_gorka_total.drop(['flag'], axis=1, inplace=True)           
    
    writer.save()


#-Main------------------------------------------------------------------
if __name__ == "__main__":
  Main()

