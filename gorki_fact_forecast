import xlsxwriter
import pandas as pd
import math
import runpy
import os

# загружаем исходные данные по фактическому потреблению

df_consumption = pd.read_excel('C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/MARCH_MB51.xlsx', dtype={'Material': 'str'})

# вводим колонку с номером недели
df_consumption['Week_Number'] = df_consumption['Entry Date'].dt.week

# считаем сумму по потреблению материала за конкретную неделю
consumption_total = df_consumption.groupby(['Material', 'Week_Number'])["Quantity"].apply(lambda x : x.sum())
consumption_total = consumption_total.to_frame().reset_index()

# определеяем период планирования (мин номер недели и максимальный)
#len(df_consumption['Week_Number'].value_counts())

min_week_num = int(df_consumption['Week_Number'].min())
max_week_num = int(df_consumption['Week_Number'].max())
gorka_size = max_week_num -min_week_num+1

# составляем матрицу "заготовку" для заполнения данными размером min_wek_num x max_week_num
df_gorka = pd.DataFrame(index=range(gorka_size),columns=range(gorka_size))

# меняем названия колонок и рядов на номера недель 
df_gorka.columns = [str(i) for i in range(min_week_num,max_week_num+1)]
df_gorka.index = [str(i) for i in range(min_week_num,max_week_num+1)]



# инициализирем файл, в который будут выгружаться данные
writer = pd.ExcelWriter('C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/gorka_total.xlsx', engine='xlsxwriter')
workbook  = writer.book

# инициализируем общую таблицу, в которой будут содержаться все данные по каждой позиции
df_gorka_total = df_gorka.iloc[:0,:]

df_gorka_total.to_excel(writer, sheet_name='Sheet1', index=False, float_format = "%0.1f")
worksheet = writer.sheets['Sheet1']

# составляем список уникальных id материалов
material_list = consumption_total ['Material'].unique().tolist()

list_of_forecasts = os.listdir('C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/пример горки от Ольги/Forecasts/')

for material_id in material_list:
    
    
    
# заполняем данными по фактическому потреблению
    for i in range(df_gorka.shape[0]):
        for j in range (i+1):
        

        
            if int(df_gorka.columns.values[i]) not  in list(consumption_total.loc[(consumption_total['Material'] == material_id)].iloc[:,1].astype(int)) :
            
                df_gorka.iloc[i,j] = 0  
            else:
                df_gorka.iloc[i,j] = int(math.ceil(abs(consumption_total.loc[(consumption_total['Week_Number'] == int(df_gorka.columns.values[i])) & 
                              (consumption_total['Material'] == material_id)].iloc[0,2])))
           
        
            df_gorka['material_id']=material_id
        
          
   
            
#  копируем данные из "верхней" ячейки на всю колонку                                   
    for m in range(df_gorka.shape[0]):
        for n in range (m+1,df_gorka.shape[0]):
            df_gorka.iloc[n,m] = df_gorka.iloc[n-1,m]  



#    os.system( 'python C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/gorki_forecast_loop.py')
 #   runpy.run_path('C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/gorki_forecast_loop.py')




##############################################    




    
    
    
    for forecast in list_of_forecasts:
            
        df_forecast = pd.read_excel('C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/пример горки от Ольги/Forecasts/' + forecast, dtype={'Material': 'str'})
        #df_forecast = pd.read_excel('C:/Users/Maksim.Smirnov/OneDrive - Unilever/Documents/Проекты/Горки/пример горки от Ольги/Forecasts/прогноз 15.xlsx' , dtype={'Material': 'str'})
        
        #удаляем последнюю колонку
        df_forecast = df_forecast.iloc [:, :(len(df_forecast.columns)-1)]
        
        
        #colnames_list = df_forecast.columns
        
        
        # NB! уточнить, если номер колонки может меняться, тогда написать обработчик ошибки
        # номер колонки, где указана первая неделья прогноза всегда 3
        # номер колонки в которой содержится "первая" неделя 
        first_week_num = 2 #df_forecast.columns.get_loc("Calendar Year/Week")+1
        all_week_nums_raw = list(df_forecast.columns[first_week_num:len(df_forecast.columns)])
        
        
        
        def fun_week_num_split (x):
            week_num = x.split('.')[0]
            return week_num
        
        def fun_int (x):
            int_num = str(int(x))
            return int_num
             
        all_week_nums = list(map(fun_week_num_split, df_forecast.columns[:]))
        
        #[list(map(fun_int, x)) for x in all_week_nums[first_week_num:40]]
        
        
        # меняем названия колонок на номера недель
        #df_forecast.columns [first_week_num:50]= list(map(fun_int, all_week_nums[first_week_num:50]))
        
        df_forecast = df_forecast.rename(columns=dict(zip(df_forecast.columns[first_week_num:len(df_forecast.columns)], 
                                                          list(map(fun_int, all_week_nums[first_week_num:len(df_forecast.columns)])) )))
        
        # ищем индексы вхождения номера первой указанной недели, в названиях колонок
        # номера недель после годового цикла повторяются, а для очтета "горка" нужны только уникальные "ближайшие" недели
        # неободимо отбросить те, которые повторятся после годового цикла
        repeated_week_cycle = [i for i, e in enumerate(df_forecast.columns) if e == df_forecast.columns[2]] # df_forecast.columns[2] - номер "первой" недели прогноза
        
        # "обрезаем" таблицу, если годовой цикл начался снова
        if len (repeated_week_cycle) > 1:
            df_forecast = df_forecast.iloc[:, :repeated_week_cycle[1]]
        else:
            df_forecast = df_forecast   
        
        
        
        # делаем выборку для конкретного материала из общего файла с прогнозом
        if df_forecast.loc[df_forecast['Material']==df_gorka.iloc[0]['material_id']].shape[0] == 0:
            continue
           
            
        df_id_material_forecast =   df_forecast.loc[df_forecast['Material']==df_gorka.iloc[0]['material_id']] 
        
            
           
        
        if list_of_forecasts.index(forecast)>0:
            df_gorka_forecast = pd.concat([df_gorka_forecast, df_id_material_forecast.iloc[:,0:len(df_id_material_forecast.columns)]])
        else:
            df_gorka_forecast = pd.concat([df_gorka, df_id_material_forecast.iloc[:,0:len(df_id_material_forecast.columns)]])
        
        #df_gorka_forecast = pd.concat([df_gorka, df_id_material_forecast.iloc[:,0:len(df_id_material_forecast.columns)]])
        
        

        
        # "обрезаем" лишнне после соеденения таблиц
        df_gorka_forecast = df_gorka_forecast.iloc[0:df_gorka.shape[0]+1, 0:df_gorka.shape[1]]
        
        # если в файле с прогнозом не указаны номера недель, которые попали в отчет "горка", то нужно перейти обработке следующего файла с прогнозом
       
        if not df_forecast.columns[2] in list(df_gorka.index) :
            continue
        
        # индекс строки, которая соответствует недели, на которой был составлен прогноз и которую нужно найти в горке по горизонтали
        forecast_week_number_index = list(df_gorka.index).index(df_forecast.columns[2])
        
        df_gorka_forecast.iloc[forecast_week_number_index, (forecast_week_number_index+1):df_gorka_forecast.shape[1]-1] = df_gorka_forecast.iloc[df_gorka_forecast.shape[0]-1, (forecast_week_number_index+1):df_gorka_forecast.shape[1]-1]
        
        
        # удаляем 1 ряд снизу
        df_gorka_forecast.drop(df_gorka_forecast.tail(1).index,inplace=True)


















































    df_gorka_total = pd.concat([df_gorka_total, df_gorka_forecast])
    
    
# обогащаем результирущую таблицу названиями позиций
df_gorka_total = pd.merge(df_gorka_total, 
df_consumption.drop_duplicates(subset=['Material'])[['Material','Material Description']], 
                                how='left', left_on='material_id', right_on='Material')
        
      
df_gorka_total = df_gorka_total.drop('Material', 1)

#вводим колонку с номерами недель, попавшими в отчет, делаем это для каждой позиции   
repeat_arr = list(range(min_week_num , max_week_num+1))
df_gorka_total = df_gorka_total.join(pd.DataFrame(repeat_arr * int((len(df_gorka_total)/len(repeat_arr)+1)),columns=['week_num']))


#меняем колонки местами
cols_to_order = ['material_id', 'Material Description', 'week_num']
new_columns = cols_to_order + (df_gorka_total.columns.drop(cols_to_order).tolist())
df_gorka_total = df_gorka_total[new_columns]    



    
df_gorka_total.to_excel(writer, sheet_name='Sheet1', index=False, float_format = "%0.1f")
worksheet = writer.sheets['Sheet1']    

# проходим циклом по ячейкам для форматирования
for i in range(df_gorka_total.shape[0]):
    
    if i % gorka_size == 0:
        t =0
    else:
        t= i % gorka_size
    
    for j in range (2,t+3):
        # инициализиаруем ячейку, к которой будет применено форматирование, получаем значение формата "А1"
        range_df = chr(98+j).upper()+str(i+2) 

        # задаем формат, который будет применен для ячейки
        format1 = workbook.add_format({'bg_color': '#ACAAAA',
                                'font_color': '#9C0006',
                                'border':1
                                })
        
        # применяем формат к ячейке путем "условного" форматирования, но в качестве условия ничего 


        
# df_gorka_total.to_excel(writer, sheet_name='Sheet1', index=True, float_format = "%0.1f")не указывается
        # пример тут https://stackoverflow.com/questions/22352907/apply-format-to-a-cell-after-being-written-in-xlsxwriter
        worksheet.conditional_format(range_df, {'type': 'no_errors',
                                                'format': format1})
            
            
        # если необходимо условие, то оно задается в таком формате:
        # worksheet.conditional_format(range_df, {'type': 'cell',
        #                                    'criteria': '!=',
        #                                     'value': '5', 
        #                                    'format': format1})

# worksheet = writer.sheets['Sheet1']


writer.save()
